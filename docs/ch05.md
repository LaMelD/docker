# CH05. 쿠버네티스 입문

## 1. 쿠버네티스란 무엇인가?

- INTRO
    - 컨테이너 운영을 자동화하기 위한 컨테이너 오케스트레이션 도구( 구글의 주도로 개발되었다. )
    - 컨테이너를 이용한 어플리케이션 배포할 수 있다.
    - 다양한 운영 관리 업무를 자동화할 수 있다.
    - 컨테이너 배치, 스케일링, 로드벨런싱, 헬스 체크 등 기능을 갖추고 있다.

- 도커의 부상과 쿠버네티스의 탄생
    - 배포 및 컨테이너 배치 전략, 스케일-인 및 스케일-아웃 서시스 디스커버리, 운영 편의성 등 문제가 있었다.
    - 컨테이너 오케스트레이션 도구의 발표 : 아파치 메소스, AWS의 ECS
    - 2014년 구글이 오픈소스로 공개한 쿠버네티스.
    - 오플 소스 소프트웨어이면서도 컨테이너 초창기부터 구글의 노하우가 잘 녹아 있어 다양한 상황에 잘 대응하는 유연성을 갖고 있다.
    - 구글 외부로부터도 많은 컨트리뷰션을 받아들일 수 있는 체제로 프로젝트가 운영된다는 점도 많은 개발자가 쿠버네티스를 애용하게 된 원인의 하나였다.

- 클라우드 플랫폼의 쿠버네티스 지원
    - GCP(Google Cloud Platform)의 GKE(Google Kubernetes Engine)
    - 마이크로소프트 Azure의 AKS(Azure Kubernetes Service)
    - 아마존 AWS(Amazon Web Service)의 EKS(Elastic Kubernetes Service)

- 도커에 정식 통합
    - 2017년 10월에 도커와 쿠버네티스의 통합이 정식으로 발표되었다.
    - 통합 자체는 아직 실험 단계에 있지만, 개발 작업이 활발히 진행되고 있다.

- 쿠터네티스의 역할
    - 도커
        - 컨테이너를 관리하는 데몬인 dockerd와 명령행 도구로 구성
    - 스웜
        - 여러 대의 호스트를 묶어 기초적인 컨테이너 오케스트레이션 기능을 제공하는 도커 관린 기술
    - 쿠버네티스
        - 스웜보다 충실한 기능을 갖춘 컨테이너 오케스트레이션 시스템이자 도커를 빗해 여러 가지 컨테이너 런타임을 다룰 수 있다.
        - 컴포즈/스태ㄱ/스웜의 기능을 통합해 더 높은 수준의 관리 기능을 제공하는 도구라고 보면 된다.

## 2. 로컬 PC에서 쿠버네티스 실행 --> 구축은 6장에서 다루겠다.
- kubeadm, kubespray : 클러스터를 구축하기 위해 사용하는 툴
- kubelet : 클러스터의 모든 머신에서 실행되며 Pod 및 컨테이너 시작 등의 작업을 수행하는 구성 요소
- kubectl : 쿠버네티스를 다루기 위한 명령행 도구
    - curl로 최신 릴리즈 다운로드
        ```
        $ curl -LO https://storage.googleapis.com/kubernetes-release/release/`curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt`/bin/linux/amd64/kubectl
        ```
    - curl로 특정 릴리즈 다운로드 -> `curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt`을 바꾼다.
        ```
        $ curl -LO https://storage.googleapis.com/kubernetes-release/release/v1.18.0/bin/linux/amd64/kubectl
        ```
    - kubectl 바이너리를 실행 가능하게 만든다.
        ```
        $ chmod +x ./kubectl
        ```
    - 바이너리를 PATH가 설정된 디렉터리로 옮긴다.
        ```
        $ sudo mv ./kubectl /usr/local/bin/kubectl
        ```
    - 설치한 버전을 확인한다.
        ```
        $ kubectl version --client
        ```
- 대시보드
    - apply(배포)
        ```
        $ kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v1.8.3/src/deploy/recommended/kubernetes-dashboard.yaml
        ```
    - 확인
        ```
        $ kubectl get pod --namespace=kube-system -l k8s-app=kubernetes-dashboard
        ```
    - 웹 브라우저로 대시보드를 볼 수 있도록 프록시 서버 설정
        ```
        $ kubectl proxy
        ```

## 3. 쿠버네티스의 주요 개념

- 쿠버네티스 리소스 : 애플리케이션을 구성하는 부품과 같은 것으로 노드, 네임스페이스, 파드 등을 가리킨다.
- 컨테이너와 리소스는 구성 요소로서의 수준이 다른다.

|리소스|용도|
|:---|:---|
|노드|컨테이너가 배치되는 서버|
|네임스페이스|쿠버네티스 클러스터 안의 가상 클러스터|
|파드|컨테이너의 집합 중 가장 작은 단위로, 컨테이너의 실행 방법을 정의한다.|
|레플리카세트|같은 스펙을 갖는 파드를 여러 개 생성하고 관리하는 역할을 한다.|
|디플로이먼트|레플리카 세트의 리비전을 관리한다.|
|서비스|파드의 집합에 접근하기 위한 경로를 정의한다.|
|인그레스|서비스를 쿠버네티스 클러스터 외부로 노출시킨다.|
|컨피그맵|설정 정볼르 정의하고 파드에 전달한다.|
|퍼시스턴트볼륨|파드가 사용할 스토리지의 크기 및 종류를 정의|
|퍼시스턴트볼륨클레임|퍼시스턴트 볼륨을 동적으로 확보|
|스토리지클래스|퍼시스턴트 볼륨이 확보하는 스토리지의 종류를 정의|
|스테이트풀세트|같은 스펙으로 모두 동일한 파드를 여러 개 생성하고 관리한다.|
|잡|상주 실행을 목적으로 하지 않는 파드를 여러 개 생성하고 정상적인 종료를 보장한다.|
|크론잡|크론 문법으로 스케줄링되는 잡|
|시크릿|인증 정보 같은 기밀 데이터를 정의|
|롤|네임스페이스 안에서 조작 가능한 쿠버네티스 리소스의 규칙을 정의한다.|
|롤바인딩|쿠버네티스 리소스 사용자와 롤을 연결 짓는다.|
|클러스터롤|클러스터 전체적으로 조작 가능한 쿠버네티스 리소스의 규칙을 정의한다.|
|클러스터롤바인딩|쿠버네티스 리소스 사용자와 클러스터롤을 연결 짓는다.|
|서비스 계정|파드가 쿠버네티스 리소스를 조작할 때 사용하는 계정|

## 4. 쿠버네티스 클러스와 노드

- 클러스터 : 쿠버네티스의 여러 리소스를 관리하기 위한 집합체
- 노드 : 쿠버네티스 클러스터의 관리 대상으로 등록된 도커 호스트로, 컨테이너가 배치되는 대상
- 클러스터에 배치된 노드의 수, 노드의 사양 등에 따라 배치할 수 있는 컨테이너 수가 결정된다.
- 클러스터의 처리 능력은 노드에 의해 결정된다.
- 노드 확인 명령
    ```
    $ kubectl get nodes
    ```

## 5. 네임스페이스

- 네임스페이스 : 클러스터 안에 가상 클러스터
- 클러스터를 처음 구축하면 default, docker, kube-public, kube-system의 네임스페이스 4개가 이미 만들어져 있다.
- 확인
    ```
    $ kubectl get namespaces
    ```
- 네임스페이스는 개발팀이 일정 규모 이상일 때 유용하다.
- 네임스페이스마다 권한을 설정할 수 있으므로 더욱 견고하고 세세하게 권한을 제어할 수 있다.

## 6. 파드(pod)

- 파드 : 컨테이너가 모인 집합체 단위, 하나 이상의 컨테이너로 이루어진다.
- 결합이 강한 컨테이너를 파드로 묶어 일괄 배포한다.
- 컨테이너가 하나인 경우에도 파드로 배포한다.
- [그림1]
- [그림2]
- 마스터 노드는 관리용 컴포넌트가 담긴 파드만 배포된 노드이다.
- 어플리케이션에 사용되는 파드는 배포할 수 없다.

- 파드 생성 및 배포하기
    - 3장에서 사용했던 nginx-proxy와 echo 어플리케이션, 2개의 컨테이너를 포함하는 파드를 배포한다.
    - simple-pod.yaml
        ```yaml
        apiVersion: v1
        kind: Pod
        metadata:
            name: simple-echo
        spec:
            containers:
                - name: nginx
                  image: gihyodocker/nginx:latest
                  env:
                    - name: BACKEND_HOST
                      value: localhost:8080
                  ports:
                    - containerPort: 80
                - name: echo
                  image: gihyodocker/echo:latest
                  ports:
                    - containerPort: 8080
        ```
        - kind : 이 파일에서 정의하는 쿠버네티스 리소스의 유형을 지정, spec 아래의 스키마가 변화한다.
        - metadata : 리소스에 부여되는 메타데이터. metadata.name 속성 값이 이 리소스의 이름이 된다.
        - spec : 리소스를 정의하기 위한 속성으로, 파드의 경우 파드를 구성하는 컨테이너를 containers 아래에 정의한다.
        - containers : name(컨테이너의 이름), image(이미지 태그값), ports(노출시킬 포트), env(환경변수)
    - 쿠버네티스 클러스터 배포
        ```
        $ kubectl apply -f simple-pod.yaml
        ```
        - -f 옵션으로 매니페스트 파일에 대한 경로를 지정한다.
        - apply 명령으로 배포한다.

- 파드 다루기
    - 파드 목록 가져오기
        ```
        $ kubectl get pod
        ```
    - 컨테이너 접근
        ```
        $ kubectl exec -it simple-echo sh -c nginx
        ```
        - 컨테이너가 여러 개인 경우에는 -c 옵션에 컨테이너 명을 지정한다.
    - 표준 출력을 화면에 출력
        ```
        $ kubectl log -f simple-echo -c echo
        ```
    - 파드의 삭제
        ```
        $ kubectl delete pod simple-echo        # 사용이 끝난 리소스 삭제
        $ kubectl delete -f simple-pod.yaml     # 매니페스트에 작성된 리소스 전체가 삭제
        ```

## 7. 레플리카세트

- 파드를 정의한 매니페스트 파일로는 하나밖에 생성할 수 없다.
- 같은 파드를 여러 개 실행해 가용성을 확보해야 하는 경우 사용한다.
- 똑같은 정의를 갖는 파드를 여러 개 생성하고 관리하기 위한 리소스
- 파드의 정의 자체도 레플리카세트를 정의한 yaml 파일에 작성하므로 파드의 설정을 따로 둘 필요 없이 파일 하나로 정의를 완결지을 수 있다.
- simple-replicaset.yaml
    ```yaml
    apiVersion: v1
    kind: ReplicaSet
    metadata:
        name: echo
        labels:
            app: echo
    spec:
        replicas: 3
        selector:
            matchLabels:
                app: echo
        template:   # template 아래는 파드 리소스 정의와 같다.
            metadata:
                labels:
                    app: echo
            spec:
                containers:
                    - name: nginx
                      image: gihyodocker/nginx:latest
                      env:
                        - name: BACKEND_HOST
                          value: localhost:8080
                      ports:
                        - containerPort: 80
                    - name: echo
                      image: gihyodocker/echo:latest
                      ports:
                        - containerPort: 8080
    ```