# CH04. 스웜을 이용한 실전 어플리케이션 개발

## 1. 웹 어플리케이션 구성

- 어플리케이션의 요구 조건
    - TODO를 등록, 수정, 삭제할 수 있다.
    - 등록된 TODO의 목록을 출력할 수 있다.
    - 브라우저에서 사용할 수 있는 웹 어플리케이션이다.
- 아키텍처
    - 오케스트레이션 시스템은 도커 스웜 사용
    - `[아키텍처]`
    - 구성 요소

        |이미지명|용도|서비스명|스택명|
        |:---|:---|:---|:---|
        |MysQL|데이터스토어|mysql_master, mysql_slave|MySQL|
        |API|데이터스토어를 다룰 API 서버|app_api|Application|
        |Web|뷰 생성을 담당하는 어플리케이션 서버|frontend_web|Frontend|
        |Nginx|프록시 서버|app_nginx, frontend_nginx|Appication Frontend|
    
    - MySQL
        - 데이터 스토어
        - 마스터-슬래브 구조로 마스터에 저장, 슬레이브로 읽기
    - API
        - RESTful API
        - DB에 접근한다.
    - 웹 UI
        - DB에 접근하지 않고 API를 경유한다.
        - Node.js를 사용한다.
- Nginx
    - 캐싱, 백엔드에 대한 유연한 라우팅, 접근 로그 생성 등의 역할을 겸한다.
    - 배치 전략
        - `[배치전략]`
        - `docker container exec -it manager docker network create --driver=overlay --attachable todoapp` : 네트워크 생성
- TODO 어플리케이션의 전체 구조
    - 데이터 스토어 역할을 할 MySQL 서비스를 마스터-슬레이브 구조로 구축
    - MySQL과 데이터를 주고받을 API 구현
    - Nginx를 웹 어플리케이션과 API 사에서 리버스 프록세 역할을 하도록 설정
    - API를 사용해 서버 사이드 렌더링을 수행할 웹 어플리케이션 구현
    - 프론트엔드 쪽에 리버스 프록시 배치

## 2. MySQL 서비스 구축

- MySQL 이미지를 만들기 위한 리포지토리 클론
    - `git clone httpd://github.com/gihyodocker/tododb`
    - clone 받은 리포지토리를 기반으로 이미지를 구성한다.
- 데이터베이스 컨테이너 구성
    - MySQL 컨테이너는 도커 허브에 등록된 mysql:5.7 이미지를 기반으로 생성한다.
    - 마스터-블레이브 컨테이너는 두 역할을 모두 수행할 수 있는 하나의 이미지로 생성한다.
    - MYSQL_MASTER 환경 변수의 유무에 따라 컨테이너가 서로 마스터로 동작할지, 슬레이브로 동작할지가 결정된다.
    - replicas 값을 조절해 슬레이브를 늘릴 수 있게 한다. 이때 마스터, 슬레이브 모두 일시 정지(다운타임)를 허용한다.
- 인증 정보
    - master

        |환경 변수 이름|내용|값|
        |:---|:---|:---|
        |MYSQL_ROOT_PASSWORD|root 사용자 패스워드|gihyo|
        |MYSQL_DATABASE|TODO 어플리케이션에서 사용할 데이터 베이스|tododb|
        |MYSQL_USER|데이터베이스 사용자명|gihyo|
        |MYSQL_PASSWORD|패스워드|gihyo|
        |MYSQL_MASTER|마스터 여부|true|

    - slave

        |환경 변수 이름|내용|값|
        |:---|:---|:---|
        |MYSQL_MASTER_HOST|마스터 호스트명|master|
        |MYSQL_ROOT_PASSWORD|root 사용자 패스워드|gihyo|
        |MYSQL_DATABASE|TODO 어플리케이션에서 사용할 데이터베이스|tododb|
        |MYSQL_USER|데이터베이스 사용자명|gihyo|
        |MYSQL_PASSWORD|패스워드|gihyo|
        |MYSQL_REPL_USER|마스터에 등록할 레플리케이션 사용자|repl|
        |MYSQL_REPL_PASSWORD|레플리케이션 사용자 패스워드|gihyo|

- MySQL 설정 : etc/mysql/mysql.conf.d/mysqld.cnf
    ```cnf
    [mysqld]
    character-set-server = utf8mb4
    collation-server = utf8mb4_general_ci
    pid-file        = /var/run/mysqld/mysqld.pid
    socket          = /var/run/mysqld/mysqld.sock
    datadir         = /var/lib/mysql
    #log-error      = /var/log/mysql/error.log
    # By default we only accept connections from localhost
    #bind-address   = 127.0.0.1
    # Disabling symbolic-links is recommended to prevent assorted security risks
    symbolic-links=0
    relay-log=mysqld-relay-bin
    relay-log-index=mysqld-relay-bin

    log-bin=/var/log/mysql/mysql-bin.log

    ```
    - log-bin
        - 레플리케이션을사용하려면 바이너리 로그가 필요하다.
        - log-bin은 마스터와 슬레이브 모두 사용하기 때문에 설정에 차이가 없다.
    - server-id
        - MySQL 서버를 식별하기 위한 유일 값이다.
        - 마스터와 슬레이브로 구성된 스택 안에서 중복이 없도록 설정해야한다.
        - log-bin 아래줄에 생성되도록 tododb/add-server-id.sh에 아래와 같이 작성한다.
            ```sh
            #!/bin/bash -e
            OCTETS=(`hostname -i | tr -s '.' ' '`)

            MYSQL_SERVER_ID=`expr ${OCTETS[2]} \* 256 + ${OCTETS[3]}`
            echo "server-id=$MYSQL_SERVER_ID" >> /etc/mysql/mysql.conf.d/mysqld.cnf
            ```
            - 컨테이너의 IP 주소에서 3,4 번째 옥텟 값을 뽑아 서버 간에 중복되지 않는 server-id 값을 설정한다.
- 레플리케이션 설정
    - tododb/prepare.sh
        ```sh
        #!/bin/bash -e

        # (1) 환경 변수로 마스터와 슬레이브 지정
        if [ ! -z "$MYSQL_MASTER" ]; then
            echo "this container is master"
            exit 0
        fi

        echo "prepare as slave"

        # (2) 슬레이브에서 마스터와 통신 가능 여부
        if [ -z "$MYSQL_MASTER_HOST" ]; then
            echo "mysql_master_host is not specified" 1>&2
            exit 1
        fi

        while :
        do
            if mysql -h $MYSQL_MASTER_HOST -u root -p$MYSQL_ROOT_PASSWORD -e "quit" > /dev/null 2>&1 ; then
                echo "MySQL master is ready!"
                break
            else
                echo "MySQL master is not ready"
            fi
            sleep 3
        done

        # (3) 마스터에 레플리케이션용 사용자 생성 및 권한 부여
        IP=`hostname -i`
        IFS='.'
        set -- $IP
        SOURCE_IP="$1.$2.%.%"
        mysql -h $MYSQL_MASTER_HOST -u root -p$MYSQL_ROOT_PASSWORD -e "CREATE USER IF NOT EXISTS '$MYSQL_REPL_USER'@'$SOURCE_IP' IDENTIFIED BY '$MYSQL_REPL_PASSWORD';"
        mysql -h $MYSQL_MASTER_HOST -u root -p$MYSQL_ROOT_PASSWORD -e "GRANT REPLICATION SLAVE ON *.* TO '$MYSQL_REPL_USER'@'$SOURCE_IP';"

        # (4) 마스터에 binlog 포지션 정보 확인
        MASTER_STATUS_FILE=/tmp/master-status
        mysql -h $MYSQL_MASTER_HOST -u root -p$MYSQL_ROOT_PASSWORD -e "SHOW MASTER STATUS\G" > $MASTER_STATUS_FILE
        BINLOG_FILE=`cat $MASTER_STATUS_FILE | grep File | xargs | cut -d' ' -f2`
        BINLOG_POSITION=`cat $MASTER_STATUS_FILE | grep Position | xargs | cut -d' ' -f2`
        echo "BINLOG_FILE=$BINLOG_FILE"
        echo "BINLOG_POSITION=$BINLOG_POSITION"

        # (5) 레플리케이션 시작
        mysql -u root -p$MYSQL_ROOT_PASSWORD -e "CHANGE MASTER TO MASTER_HOST='$MYSQL_MASTER_HOST', MASTER_USER='$MYSQL_REPL_USER', MASTER_PASSWORD='$MYSQL_REPL_PASSWORD', MASTER_LOG_FILE='$BINLOG_FILE', MASTER_LOG_POS=$BINLOG_POSITION;"
        mysql -u root -p$MYSQL_ROOT_PASSWORD -e "START SLAVE;"

        echo "slave started"

        ```
        1. 환경 변수에 따라 마스터/슬레이브로 설정
            - MYSQL_MASTER 값에 따라 마스터 혹은 슬레이브로 동작
        2. 슬레이브와 마스터 간의 통신 확인
            - 슬레이브에서 마스터에 MySQL 명령ㅇ르 실행하려면 호스트명을 -h 옵션값으로 주면 된다.
            - 3초마다 마스터와 통신을 확인해 확인되는 경우 무한 루프에서 바로 탈출한다.
        3. 마스터에 레플리카 사용자 및 권한추가
        4. 마스터 binlog의 포지션 설정
        5. 레플리케이션 시작
- MySQL(master/slave) Dockerfile
    ```Dockerfile
    FROM mysql:5.7

    # (1) 패키지 업데이트 및 wget 설치
    RUN apt-get update
    RUN apt-get install -y wget

    # (2) entrykit 설치
    RUN wget https://github.com/progrium/entrykit/releases/download/v0.4.0/entrykit_0.4.0_linux_x86_64.tgz
    RUN tar -xvzf entrykit_0.4.0_linux_x86_64.tgz
    RUN rm entrykit_0.4.0_linux_x86_64.tgz
    RUN mv entrykit /usr/local/bin/
    RUN entrykit --symlink

    # (3) 스크립트 및 각종 설정 파일 복사
    COPY add-server-id.sh /usr/local/bin/
    COPY etc/mysql/mysql.conf.d/mysqld.cnf /etc/mysql/mysql.conf.d/
    COPY etc/mysql/conf.d/mysql.cnf /etc/mysql/conf.d/
    COPY prepare.sh /docker-entrypoint-initdb.d
    COPY init-data.sh /usr/local/bin/
    COPY sql /sql

    # (4) 스크립트, mysqld 실행
    ENTRYPOINT [ \
        "prehook", \
        "add-server-id.sh", \
        "--", \
        "docker-entrypoint.sh" \
    ]

    CMD ["mysqld"]
    ```
    1. wget 설치
    2. entrykit 설치
    3. MySQL 컨테이너를 구성하기 위한 파일과 스크립트를 COPY
    4. 스크립트 및 mysqld 실행
        - ENTRYPOINT 인스트럭션 값 안에 지정된 docker-entrypoint.sh 스크립트는 tododb에는 없지만 기반 이미지인 mysql:5.7에 포함된 파일이므로 실행할 수 있다.
        - 이 이미지는 데이터베이스 서버 시작이 완료된 시점마다 /docker-entrypoint-initdb.d 디렉터리에 위치한 스크립트를 실행한다.
        - add-server-id.sh 스크립트를 docker-entrypoint.sh보다 먼저 실행할 수 있다.
- 빌드
    ```
    $ docker image build -t tododb:latest .
    $ docker image tag tododb:latest localhost:5000/tododb:latest
    $ docker push localhost:5000/tododb:latest
    ```
- 스웜에서 마스터 및 슬레이브 실행
    - stack/todo-mysql.yml 작성
        ```yml
        version: "3"
        services:
        master:
            image: registry:5000/tododb:latest
            ports:
              - 3306:3306
            deploy:
              replicas: 1
              placement:
                constraints: [node.role != manager]
            environment:
              MYSQL_ROOT_PASSWORD: gihyo
              MYSQL_DATABASE: tododb
              MYSQL_USER: gihyo
              MYSQL_PASSWORD: gihyo
              MYSQL_MASTER: "true"
            networks:
              - todoapp

        slave:
            image: registry:5000/tododb:latest
            deploy:
              replicas: 2
              placement:
                constraints: [node.role != manager]
            depends_on:
              - master
            environment:
              MYSQL_MASTER_HOST: master
              MYSQL_ROOT_PASSWORD: gihyo
              MYSQL_DATABASE: tododb
              MYSQL_USER: gihyo
              MYSQL_PASSWORD: gihyo
              MYSQL_REPL_USER: repl
              MYSQL_REPL_PASSWORD: gihyo
            networks:
              - todoapp

        networks:
          todoapp:
            external: true
        ```
    - stack 생성 및 조회
        ```
        $ docker contaienr exec -it manager docker stack deploy -c /stack/todo-mysql.yml todo_mysql
        $ docker container exec -it manager docker stack ps todo_mysql
        $ docker container exec -it manager docker service ls
        ```
- MySQL 컨테이너 확인 및 초기 데이터 투입
    - 노드 ID와 테스크 ID 알아오기 및 데이터 삽입
        ```
        $ docker container exec -it manager stack ps todo_mysql
        $ docker container exec -it {{master 노드}} docker container ls
        $ docker container exec -it {{msster 노드}} docker contianer exec -it {{컨테이너 id}} init-data.sh
        ```
    - 삽입 확인
        ```
        $ docker container exec -it {{master 노드}} docker container exec -it {{컨테이너 id}} mysql -u root -p[비밀번호] tododb
        > select * from todo\G
        ```
    - 마스터에 적용한 데이터가 슬레이브에도 적용되었는지 확인한다.

## 3. API 서비스 구축

- API 이미지를 만들기 위한 리포지토리 클론
    - `git clone httpd://github.com/gihyodocker/todoapi`
    - clone 받은 리포지토리를 기반으로 이미지를 구성한다.
- todoapi의 기본 구조
    ```
    todoapi
    ├── .dockerignore       # 컨테이너에 넣지 않을 파일 및 디렉터리 정의
    ├── cmd                 
    │   └── main.go         # 어플리케이션을 시작함
    ├── db.go               # mysql에 접속
    ├── Dockerfile          # Dockerfile
    ├── env.go              # 환경변수를 적절히 생성함
    ├── go.mod
    ├── go.sum
    └── handler.go          # HTTP 요청을 받으면 비즈니스로직을 수행하고 응답을 돌려줌
    ```
    - cmd/main.go : 어플리케이션 시작
        ```go
        package main

        import (
                "fmt"
                "log"
                "net/http"
                "os"

                "github.com/gihyodocker/todoapi"
        )

        func main() {

                // (1) 환경변수 저장 구조체
                env, err := todoapi.CreateEnv()
                if err != nil {
                        fmt.Fprint(os.Stderr, err.Error())
                        os.Exit(1)
                }

                // (2) MySQL 마스터에 접속하는데 사용하는 구조체
                masterDB, err := todoapi.CreateDbMap(env.MasterURL)
                if err != nil {
                        fmt.Fprintf(os.Stderr, "%s is invalid database", env.MasterURL)
                        return
                }

                // (3) MySQL 슬레이브에 접속하는 데 사용하는 구조체
                slaveDB, err := todoapi.CreateDbMap(env.SlaveURL)
                if err != nil {
                        fmt.Fprintf(os.Stderr, "%s is invalid database", env.SlaveURL)
                        return
                }

                mux := http.NewServeMux()

                // (4) 헬스체크에 사용되는 API 핸들러
                hc := func(w http.ResponseWriter, r *http.Request) {
                        log.Println("[GET] /hc")
                        w.Write([]byte("OK"))
                }

                // (5) TODO API 핸들러
                todoHandler := todoapi.NewTodoHandler(masterDB, slaveDB)

                // (6) 핸들러 API 엔드포인트로 등록
                mux.Handle("/todo", todoHandler)
                mux.HandleFunc("/hc", hc)

                // (7) 서버 포트 및 핸들러 설정, 서버 시작
                s := http.Server{
                        Addr:    env.Bind,
                        Handler: mux,
                }
                log.Printf("Listen HTTP Server")
                if err := s.ListenAndServe(); err != nil {
                        log.Fatal(err)
                }
        }
        ```
- 어플리케이션 환경 변수 통제
    - env.go
        ```go
        package todoapi

        import (
                "errors"
                "os"
        )

        // 환경 변수를 저장할 구조체
        type Env struct {
                Bind      string
                MasterURL string
                SlaveURL  string
        }

        func CreateEnv() (*Env, error) {

                env := Env{}

                bind := os.Getenv("TODO_BIND") // API 서버 포트 설정
                if bind == "" {
                        env.Bind = ":8080"
                }
                env.Bind = bind

                masterURL := os.Getenv("TODO_MASTER_URL") // MySQL Master 접속 정보
                if masterURL == "" {
                        return nil, errors.New("TODO_MASTER_URL is not specified")
                }
                env.MasterURL = masterURL

                slaveURL := os.Getenv("TODO_SLAVE_URL") // MySQL Slave 접속 정보
                if slaveURL == "" {
                        return nil, errors.New("TODO_SLAVE_URL is not specified")
                }
                env.SlaveURL = slaveURL

                return &env, nil
        }
        ```
- MySQL 접속 및 테이블 매핑
    - db.go
        ```go
        package todoapi

        import (
                "database/sql"
                "time"

                _ "github.com/go-sql-driver/mysql"
                gorp "gopkg.in/gorp.v1"
        )

        func CreateDbMap(dbURL string) (*gorp.DbMap, error) {

                ds, err := createDatasource(dbURL)
                if err != nil {
                        return nil, err
                }

                db := &gorp.DbMap{
                        Db: ds,
                        Dialect: gorp.MySQLDialect{
                                Engine:   "InnoDB",
                                Encoding: "utf8mb4",
                        },
                }

                db.AddTableWithName(Todo{}, "todo").SetKeys(true, "ID")
                return db, nil
        }

        func createDatasource(dbURL string) (*sql.DB, error) {

                db, err := sql.Open("mysql", dbURL)
                if err != nil {
                        return nil, err
                }

                db.SetMaxIdleConns(2)
                return db, nil
        }

        type Todo struct {
                ID      uint      `db:"id"      json:"id"`
                Title   string    `db:"title"   json:"title"`
                Content string    `db:"content" json:"content"`
                Status  string    `db:"status"  json:"status"`
                Created time.Time `db:"created" json:"created"`
                Updated time.Time `db:"updated" json:"updated"`
        }
        ```
- 핸들러 구현하기
    - handler.go
        ```go
        package todoapi

        import (
                "database/sql"
                "encoding/json"
                "fmt"
                "io/ioutil"
                "log"
                "net/http"
                "time"

                gorp "gopkg.in/gorp.v1"
        )

        // 핸들러에서 DB에 쿼리를 보낼 수 있도록 DB 접속 정보 구조체를 갖는다.
        type TodoHandler struct {
                master *gorp.DbMap
                slave  *gorp.DbMap
        }

        // Handler 생성 함수
        func NewTodoHandler(master *gorp.DbMap, slave *gorp.DbMap) http.Handler {
                return &TodoHandler{
                        master: master,
                        slave:  slave,
                }
        }

        // HTTP 요청을 받아 비즈니스 로직을 수행하고 응답을 돌려준다.
        func (h TodoHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {

                log.Printf("[%s] RemoteAddr=%s\tUserAgent=%s", r.Method, r.RemoteAddr, r.Header.Get("User-Agent"))
                switch r.Method {
                case "GET":
                        h.serveGET(w, r)
                        return
                case "POST":
                        h.servePOST(w, r)
                        return
                case "PUT":
                        h.servePUT(w, r)
                        return
                default:
                        NewErrorResponse(http.StatusMethodNotAllowed, fmt.Sprintf("%s is Unsupported method", r.Method)).Write(w)
                        return
                }
        }

        type errorResponse struct {
                Status  int    `json:"status"`
                Message string `json:"message"`
        }

        func NewErrorResponse(status int, message string) *errorResponse {
                return &errorResponse{
                        Status:  status,
                        Message: message,
                }
        }

        func (e *errorResponse) Write(w http.ResponseWriter) {
                data, err := json.Marshal(e)
                if err != nil {
                        log.Println("marshal error json is failed")
                }

                w.Header().Set("Content-Type", "application/json; charset=utf-8")
                w.WriteHeader(e.Status)
                w.Write(data)
        }

        func (h TodoHandler) serveGET(w http.ResponseWriter, r *http.Request) {

                status := r.URL.Query().Get("status")
                if status == "" {
                        status = "TODO"
                }

                result, err := h.slave.Select(Todo{}, "SELECT * FROM todo WHERE status = ? ORDER BY updated DESC", status)
                if err != nil {
                        log.Println(err.Error())
                        NewErrorResponse(http.StatusInternalServerError, "Execute Query is failed").Write(w)
                        return
                }

                todoItems := make([]*Todo, 0)

                for _, e := range result {
                        todo := e.(*Todo)
                        todoItems = append(todoItems, todo)
                }

                data, err := json.Marshal(todoItems)
                if err != nil {
                        log.Println(err.Error())
                        NewErrorResponse(http.StatusInternalServerError, "Marshal JSON is failed").Write(w)
                        return
                }

                w.Header().Set("Content-Type", "application/json; charset=utf-8")
                w.Write(data)
        }

        type TodoPostPayload struct {
                Title   string `json:"title"`
                Content string `json:"content"`
        }

        func (h TodoHandler) servePOST(w http.ResponseWriter, r *http.Request) {

                raw, err := ioutil.ReadAll(r.Body)
                if err != nil {
                        log.Println(err.Error())
                        NewErrorResponse(http.StatusInternalServerError, "Read payload is failed").Write(w)
                        return
                }

                var payload TodoPostPayload
                if err := json.Unmarshal(raw, &payload); err != nil {
                        log.Println(err.Error())
                        NewErrorResponse(http.StatusInternalServerError, "Parse payload is failed").Write(w)
                        return
                }

                now := time.Now()
                todo := Todo{
                        Title:   payload.Title,
                        Content: payload.Content,
                        Status:  "TODO",
                        Created: now,
                        Updated: now,
                }

                if err := h.master.Insert(&todo); err != nil {
                        log.Println(err.Error())
                        NewErrorResponse(http.StatusInternalServerError, "Insert Data is failed").Write(w)
                        return
                }

                w.Header().Set("Content-Type", "application/json; charset=utf-8")
                w.WriteHeader(http.StatusCreated)
        }

        type TodoPutPayload struct {
                ID      uint   `json:"id"`
                Title   string `json:"title"`
                Content string `json:"content"`
                Status  string `json:"status"`
        }

        func (h TodoHandler) servePUT(w http.ResponseWriter, r *http.Request) {

                raw, err := ioutil.ReadAll(r.Body)
                if err != nil {
                        log.Println(err.Error())
                        NewErrorResponse(http.StatusInternalServerError, "Read payload is failed").Write(w)
                        return
                }

                var payload TodoPutPayload
                if err := json.Unmarshal(raw, &payload); err != nil {
                        log.Println(err.Error())
                        NewErrorResponse(http.StatusInternalServerError, "Parse payload is failed").Write(w)
                        return
                }

                var target Todo
                if err := h.slave.SelectOne(&target, "SELECT * FROM todo WHERE id = ?", payload.ID); err != nil {
                        if err == sql.ErrNoRows {
                                NewErrorResponse(http.StatusNotFound, fmt.Sprintf("id=%d is not found", payload.ID)).Write(w)
                        } else {
                                log.Println(err.Error())
                                NewErrorResponse(http.StatusInternalServerError, "Select todo is failed").Write(w)
                        }
                        return
                }

                now := time.Now()
                todo := Todo{
                        ID:      payload.ID,
                        Title:   payload.Title,
                        Content: payload.Content,
                        Status:  payload.Status,
                        Created: target.Created,
                        Updated: now,
                }

                if _, err := h.master.Update(&todo); err != nil {
                        log.Println(err.Error())
                        NewErrorResponse(http.StatusInternalServerError, "Update Data is failed").Write(w)
                        return
                }

                w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(http.StatusOK)
        }
        ```
    - serveGET
        - 요청 파라미터 status를 받아 todo 테이블에서 select 쿼리를 실행
        - JSON 포멧으로 된 레코드의 배열을 응답으로 반환한다.
    - servePOST
        - 새로운 TODO를 추가한다.
        - JSON 포멧으로 전달하여 TODO를 추가한다.
    - servePUT
        - 이미 추가된 TODO를 수정한다.
        - id로 지정된 레코드가 이미 존재하는 경우 해당 레코드를 수정
        - id로 지정된 레코드가 없는 경우 404를 반환한다.
- API를 위한 Dockerfile
    - stack/todo-app.yml
        ```yml
        version: "3"
        services:
          api:
            image: registry:5000/todoapi:latest
            deploy:
              replicas: 2
            environment:
              TODO_BIND: ":8080"
              TODO_MASTER_URL: "gihyo:gihyo@tcp(todo_mysql_master:3306)/tododb?parseTime=true"
              TODO_SLAVE_URL: "gihyo:gihyo@tcp(todo_mysql_slave:3306)/tododb?parseTime=true"
            networks:
            - todoapp

        networks:
          todoapp:
            external: true
        ```
- 스웜에서 todoapi 서비스 실행하기

## 4. Nginx 구축

- nginx.conf 파일 구성하기
- Nginx 컨테이너의 Dockerfile
- Nginx를 거쳐 API에 접근하기

## 5. 웹 서비스 구축

- TODO API 호출 및 페이지 HTML 렌더링
- 웹 서비스의 Dockerfile
- 정적 파일을 다루는 방법
- Nginx를 통한 접근 허용
- 인그레스로 서비스 노출하기

## 6. 컨테이너 오케스트레이션을 적용한 개발 스타일