# CH03. 컨테이너 실전 구축 및 배포

## 1. 어플리케이션과 시스템 내 단일 컨테이너의 적정 비중

- header
    - 도커를 사용해 시스템을 구축한다는 것 = 자신이 만든 어플 컨테이너 + 공개된 어플/미들웨어 컨테이너

- 컨테이너 1개 = 프로새스 1개?
    - 도커는 어플리케이션 배포에 특화된 가상화 기술(어플 + 인프라 = 도커 컨테이너)
    - 정기적으로 작업을 실행하는 어플리케이션
        - 대부분 스케줄러는 외부 기능에 의존한다.
        - 스케줄러 기능이 없는 어플리케이션을 사용해 정기 작업을 실행하려면 cron을 사용하는 것이 자연스럽다.
        - cron은 1개의 상주 프로세스 형태로 동작한다.
        - 컨테이너 1개 = 프로세스 1개 방식을 택한다면 cron이 1개 컨테이너고 실행되는 작업이 또 1개 컨테이너를 차지하는 형태로 구성해야 한다.
        - 이런 방법은 지나치게 복잡하므로 간단하게 컨테이너 하나로 cron과 작업 프로세스를 모두 실행하는 방법이 좋다.
        - 예시
            - 폴더 구성
                ```
                cronjob --- task.sh
                    |- cron-example
                    |- Dockerfile
                ```
            - task.sh
                ```sh
                #!/bin/sh
                echo "[`date`] Hello!" >> /var/log/cron.log
                ```
            - cron-example
                ```
                * * * * * root sh /usr/local/bin/task.sh
                ```
            - Dockerfile
                ```Dockerfile
                FROM ubuntu:16.04
                RUN apt update
                RUN apt install -y cron
                COPY task.sh /usr/local/bin/
                COPY cron-example /etc/cron.d/
                RUN chmod 0644 /etc/cron.d/cron-example
                CMD ["cron", "-f"]
                ```
            - 도커 이미지 생성 및 컨테이너 생성
                ```
                $ docker image build -t example/cronjob:latest .
                $ docker container run -d --rm --name cronjob example/cronjob:latest
                ```
            - 로그 확인
                ```
                $ docker container exec -it cronjob tail -f /var/log/cron.log
                ```
    - 자식 프로세스를 너무 의식하지 말 것
        - 프로세스를 지나치게 의식하면 컨테이너를 제대로 사용할 수 없다.
        - 아파치 웹 서버 : 클라이언트로부터 요청을 받을 때마다 자식 프로세스를 포크한다.
        - 엔진엑스 : 마스터 프로세스와 워커프로세스, 캐시 관리 프로세스가 함께 동작한다.
        - 이런 경우까지 컨테이너 1개 = 프로세스 1개 원칙을 고수하는 것은 비현실 적이다.
    - **프로세스 1개 = 컨테이너 1개가 되는 경우도 있지만, 이를 꼭 지켜야 할 사항은 아니다.**

- 컨테이너 1개에 하나의 관심사
    - 도커 공식 입장 : Best Practices for writing Dockerfiles
        - Each container should have only one concern
    - 컨테이너 하나가 한 가지 역할이나 문제 영역(도메인)에만 집중해야 한다.

## 2. 컨테이너의 이식성

- header
    - 도커의 큰 장점 : 이식성
    - 도커를 사용하면 어플리케이션과 인프라를 컨테이너라는 단위로 분리할 수 있다.
    - 도커가 설치된 환경이라면 어떤 호스트 운영체제와 플랫폼, 온프레미스 및 클라우드 환경에서도 그대로 작동한다.

- 커널 및 아키텍처의 차이
    - 도커에서 사용되는 컨테이너형 가상화 기술은 호스트 운영 체제와 커널 리소스를 공유한다.
    - 도커 컨테이너를 실행하려면 호스트가 특정 CPU 아키텍처 혹은 운영 체제를 사용해야 한다는 의미다.

- 라이브러리와 동적 링크 문제
    - 어플리케이션이 사용하는 라이브러리에 따라 이식성을 해치는 경우도 있다.
    - 동적 링크를 사용한 어플리케이션을 도커에 사용하는 경우 문제가 발생할 수 있다.
        - 네이티브 라이브러리를 정적 링크하여 빌드하면 문제는 해결된다. 하지만 실행 파일의 크기가 커진다.
        - 도커에서 이러한 문제에 대한 해결책으로 multi-stage builds라는 메커니즘을 제안했다.
            - 컨테이너를 빌드용과 실행용으로 분리해서 사용하는 방법
            - 실행용 컨테이너를 빌드에 사용하면서 빌드에 쓰이는 도구로 인해 컨테이너가 지나치게 커지는 것을 방지한다.
    - **이러한 방법을 사용하더라도 도커의 이식성이 완벽해지는 것은 아니다.**

## 3. 도커 친화적인 어플리케이션

- 환경 변수 활용
    - 어플리케이션을 만들 때는 일반적으로 재사용성과 유연성을 가질 수 있도록 옵션을 만들어 두고, 이 옵션에 따라 어플리케이션의 동작을 제어한다.
    - 동작을 제어하는 방법
        - 실행 시 인자
        - 설정 파일
        - 어플리케이션 동작을 환경변수로 제어
        - 설정 파일에 환경 변수를 포함
    - 실행 시 인자를 사용
        - 외부에서 값을 주입받을 수 있다.
        - 인자가 어무 많아지면 매핑 처리가 복잡해지거나 CMD, ENTRYPOINT 인스트럭션 내용을 관리하기 어려워질 수 있다.
    - 설정 파일 사용
        - 컨테이너 보급 이전에도 일반적인 방식
        - 실행할 어플리케이션에 환경 이름을 부여하고, 그에 따라 설정 파일을 바꿔가며 사용하는 방식
        - 설정 파일을 컨테이너 밖에서 실행 시 전달하는 형태로 사용한다면 실행 환경을 추가해도 이미지를 새로 빌드할 필요가 없다.
        - 호스트에 위치한 환경별 설정파일을 컨테이너에 마운트해주는 것도 한 가지 방법이지만, 호스트에 대한 의존성이 생기므로 관리 운영 면에서 좋지 않다.
    - 어플리케이션 동작을 환경 변수로 제어
        - 매번 이미지를 다시 빌드하지 않아도 된다.
        - 시행착오에 드는 시간이 압도적으로 줄어든다.
        - 어플리케이션 외부에서 설정을 주입하는 형태이므로 이들 환경벼수는 어플리케이션과 별도의 저장소를 통해 관리하느 것이 일반적이다.
        - 환경변수는 그 특성상 키-값 형태로, 계층적 구조를 가지기 어렵다. 따라서 어플리케이션 쪽에서 매핑을 처리할 때 수고가 많이 든다.
    - 설정 파일에 환경 변수를 포함
        - 설정 파일에 환경 변수를 포함하여 환경변수의 장점과 설정 파일의 장점을 모두 취할 수 있다.
        - 환경별 설정 파일을 어플리케이션에 포함하는 대신, 설정 파일 템플릿에 환경 변수를 포함하는 것이다.

## 4. 퍼시스턴스 데이터를 다루는 기법

- 데이터 볼륨
    - 도커 컨테이너 안의 디렉터리를 디스크에 퍼시스턴스 데이터로 남기기 위한 메커니즘이다.
    - 호스트와 컨테이너 사이의 디렉터리 공유 및 재사용 기능을 제공한다.
    - 이미지를 수정하고 새로 컨테이너를 생성해도 같은 데이터 볼륨을 계속 사용할 수 있다.
    - 컨테이너를 파기해도 디스크에 그대로 남아있다.
    - `docker container run [options] -v [호스트_디렉토리]:[컨테이너 디렉토리] 리포지토리명[:태그] [명령] [명령인자...]`
    - 예시
        ```
        $ docker container run -v ${PWD}:/workspace gihyodocker/imagemagick:latest convert -size 100x100 xc:#000000 /workspace/test.jpg
        $ ls -al
        ```
    - 호스트 쪽 데이터 볼륨을 잘못 다루면 어플리케이션에 부정적인 영향을 줄 수 있다.

- 데이터 볼륨 컨테이너
    - 데이터 볼륨 : 호스트-컨테이너 디렉터리 공유
    - 데이터 볼륨 컨테이너 : 컨테이너-컨테이너 디렉터리 공유
    - 데이터를 저장하는 것만이 목적인 컨테이너다.
    - 데이터 볼륨 컨테이너의 볼륨은 도커에서 관리하는 영역인 호스트 머신의 /var/lib/docker/volumes/ 아래에 위치한다.
    - 도커가 관리하는 디렉터리 영역에만 영향을 미친다.
    - 호스트 머신이 컨테이너에 미치는 영향을 최소한으로 억제한다.
    - 데이터 볼륨 컨테이너가 직접 볼륨을 다뤄주므로 볼륨을 필요로 하는 컨테이너 사용할 호스트 디렉터리를 알 필요가 없고 디렉터리를 제공하는 데이터 볼륨 컨테이너만 지정하면 된다.
    - 데이터 볼륨이 데이터 볼륨 컨테이넝 안에 캡슐화되어 호스트에 대해 아는 것이 없어도 데이터를 사용할 수 있다.
    - 컨테이너 안에 든 어플리케이션과 데이터의 결합력이 더 느슨하므로 어플리케이션 컨테이너와 데이터 볼륨을 교체할 수도 있다.
    - 예시 : 데이터 볼륨에 MySQL 데이터 저장하기
        - 데이터 볼륨 컨테이너의 Dockerfile
            ```Dockerfile
            FROM busybox
            VOLUME /var/lib/mysql
            CMD ["bin/true"]
            ```
        - 데이터 볼륨 컨테이너의 이미지 생성 및 컨테이너 생성
            ```
            $ docker image build -t example/mysql-data:latest .
            $ docker container run -d --name mysql-data example/mysql-data:latest
            ```
        - Mysql 컨테이너 생성
            ```
            $ docker container run -d --rm --name mysql \
            -e MYSQL_ALLOW_EMPTY_PASSWORD="yes" \
            -e MYSQL_DATABASE="volume_test" \
            -e MYSQL_USER="test" \
            -e MYSQL_PASSWORD="qwer1234" \
            --volumes-from mysql-data \
            mysql:5.7
            ```
        - Mysql 컨테이너 접속
            ```
            $ docker container exec -it mysql mysql -u test -p volume_test
            ```

## 5. 컨테이너 배치 전략

- 도커 스웜

- 서비스

- 스택

- 스웜 클러스터 외부에서 서비스 이용하기