# CH09. 가벼운 도커 이미지 만들기

- 도커 이미지의 최적하 보다는 어플리케이션의 동작을 우선시했다.
- 일정 규모 이상의 어플리케이션을 본격적으로 구축하려면 도커 이미지 크기에도 신경 써야 한다.

## 1. 가벼운 도커 이미지가 왜 필요할까

- 이미지 크기 증가에 따라 나타는 문제
    - 이미지 크기가 미치는 영향
        - 이미지 빌드 시간(기반 이미지 다운로드 시간 포함)
        - 이미지를 도커 레지스트리에 등록하는 시간
        - 컨테이너를 실행할 호스트 혹은 노드에서 이미지를 다운로드하는 시간
    - 나비효과
        - 클러스터를 구성하는 노드의 디스크 용량 낭비
        - CI 소요 시간 증가
        - 개발 중 시행착오 소요 시간 증가로 인한 생산성 저하
        - 오토 스케일리으로 컨테이너가 투입되는 소요 시간 증가(노드에 이미지가 없는 경우 새로 받아와야 하므로)
    - 새 노드에 얼마나 빨리 도커 이미지를 배치할 수 있는가가 중요하다.

## 2. 기반 이미지를 가볍게

- scratch
    - INTRO
        - 빈 도커 이미지로, 도커가 이름을 예약한 특수 이미지다.
        - Dockerfile의 FROM 인스트럭션에서 참조만 가능하다.
        - 컨테이너 외부로부터 파일을 주입받은 후에야 실체를 갖게 된다.
        - 현재 존재하는 모든 도커 이미지의 기반 이미지를 따라가 보면 결국 이 scratch 이미지에 이르게 된다.
        - scratch 이미지는 모든 이미지의 조상 격이다.
    - scratch 이미지로 만든 이미지 빌드 들여다보기
        - ubuntu:trusty 이미지의 Dockerfile
            ```Dockerfile
            FROM scratch
            
            ADD ubuntu-trusty-core-cloudimg-amd64-root.tar.gz /

            RUN set -xe \
                \
                && echo '#!/bin/sh' > /usr/sbin/policy-rc.d \
                && echo 'exit 101' >> /usr/sbin/policy-rc.d \
                && chmod +x /usr/sbin/policy-rc.d \
                \
                && dpkg-divert --local --rename --add /sbin/initctl \
                && cp -a /usr/sbin/policy-rc.d /sbin/initctl \
                && sed -i 's/^exit.*/exit 0/' /sbin/initctl \
                \
                && echo 'force-unsafe-io' > /etc/dpkg/dpkg.cfg.d/docker-apt-speedup \
                \
                && echo 'DPkg::Post-Invoke { "rm -f /var/cache/apt/archives/*.deb /var/cache/apt/archives/partial/*.deb /var/cache/apt/*.bin || true"; };' > /etc/apt/apt.conf.d/docker-clean \
                && echo 'APT::Update::Post-Invoke { "rm -f /var/cache/apt/archives/*.deb /var/cache/apt/archives/partial*.deb /var/cache/apt/*.bin || true"; };' >> /etc/apt/apt.conf.d/docker-clean \
                && echo 'Dir::Cache::pkgcache ""; Dir::Cache::srcpkgcache "";' >> /etc/apt/apt.conf.d/docker-clean \
                \
                && echo 'Acquire::Languages "none";' > /etc/apt/apt.conf.d/docker-no-languages \
                \
                && echo 'Acquire::GzipIndexes "true"; Acquire::CompressionTypes::Order:: "gz";' > /etc/apt/apt.conf.d/docker-gzip-indexes \
                \
                && echo 'Apt::AutoRemove::SuggestsImportant "false";' > /etc/apt/apt.conf.d/docker-autoremove-suggests
            
            RUN rm -rf /var/lib/apt/lists/*
            
            RUN sed -i 's/^#\s*\(deb.*universe\)$/\1/g' /etc/apt/sources.list

            CMD ["/bin/bash"]
            ```
            - ubuntu-trusty-core-cloudimg-amd64-root.tar.gz : 우분투 운영체제를 구성하는 최소한의 파일을 디렉토리 구조 그대로 압축한 것
            - ADD 인스트럭션은 COPY와 다르게 압축해제 기능이 있다.
            - CMD 인스트럭션에 /bin/bash 명령을 지정하여 컨테이너가 /bin/bash를 포어그라운드로 실행하므로 우분투 서버 자체가 상주 형태로 실행되는 것처럼 보인다.
    - 어플리케이션을 실행하는데 운영 체제를 구성하는 파일을 모두 사용하는 것은 아니기 때문에 대부분의 파일은 쓸모없이 이미지의 용량만 차지한다.
    - 간단한 이미지 만들기
        - hello.go 작성
            ```golang
            package main
            import "fmt"

            func main() {
                fmt.Println("hello, scratch!")
            }
            ```
        - 바이너리를 복사할 수 있도록 컨테이너 밖에서 컴파일한다.
            ```
            $ GOOS=linux GOARCH=amd64 go build hello.go
            ```
        - Dockerfile 작성
            ```Dockerfile
            FROM scratch

            COPY hello /

            CMD ["/hello"]
            ```
        - 이미지 빌드
            ```
            $ docker image build ch09/hello:latest .
            ```
        - 컨테이너 실행
            ```
            $ docker container run -t ch09/hello:latest
            ```
- busybox
- alpine

## 3. 가벼운 도커 이미지 만들기



## 4. 멀티 스테이지 빌드
